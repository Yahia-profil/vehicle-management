import { asNumber, isUndefined, isNumber, normalizeObject, roundTo, ORDERED_UNITS, REVERSE_ORDERED_UNITS, HUMAN_ORDERED_UNITS } from "./impl/util.js";
import { Locale } from "./impl/locale.js";
import { Formatter } from "./impl/formatter.js";
import { parseISODuration, parseISOTimeOnly } from "./impl/regexParser.js";
import { InvalidArgumentError, InvalidDurationError, InvalidUnitError } from "./errors.js";
import { Settings } from "./settings.js";
import { Invalid } from "./types/invalid.js";
import { DateTime } from "./datetime.js";
const lowOrderMatrix = {
  weeks: {
    days: 7,
    hours: 7 * 24,
    minutes: 7 * 24 * 60,
    seconds: 7 * 24 * 60 * 60,
    milliseconds: 7 * 24 * 60 * 60 * 1e3
  },
  days: {
    hours: 24,
    minutes: 24 * 60,
    seconds: 24 * 60 * 60,
    milliseconds: 24 * 60 * 60 * 1e3
  },
  hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
  minutes: { seconds: 60, milliseconds: 60 * 1e3 },
  seconds: { milliseconds: 1e3 }
};
const casualMatrix = Object.assign({ years: {
  quarters: 4,
  months: 12,
  weeks: 52,
  days: 365,
  hours: 365 * 24,
  minutes: 365 * 24 * 60,
  seconds: 365 * 24 * 60 * 60,
  milliseconds: 365 * 24 * 60 * 60 * 1e3
}, quarters: {
  months: 3,
  weeks: 13,
  days: 91,
  hours: 91 * 24,
  minutes: 91 * 24 * 60,
  seconds: 91 * 24 * 60 * 60,
  milliseconds: 91 * 24 * 60 * 60 * 1e3
}, months: {
  weeks: 4,
  days: 30,
  hours: 30 * 24,
  minutes: 30 * 24 * 60,
  seconds: 30 * 24 * 60 * 60,
  milliseconds: 30 * 24 * 60 * 60 * 1e3
} }, lowOrderMatrix);
const daysInYearAccurate = 146097 / 400;
const daysInMonthAccurate = 146097 / 4800;
const accurateMatrix = Object.assign({ years: {
  quarters: 4,
  months: 12,
  weeks: daysInYearAccurate / 7,
  days: daysInYearAccurate,
  hours: daysInYearAccurate * 24,
  minutes: daysInYearAccurate * 24 * 60,
  seconds: daysInYearAccurate * 24 * 60 * 60,
  milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
}, quarters: {
  months: 3,
  weeks: daysInYearAccurate / 28,
  days: daysInYearAccurate / 4,
  hours: daysInYearAccurate * 24 / 4,
  minutes: daysInYearAccurate * 24 * 60 / 4,
  seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
  milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
}, months: {
  weeks: daysInMonthAccurate / 7,
  days: daysInMonthAccurate,
  hours: daysInMonthAccurate * 24,
  minutes: daysInMonthAccurate * 24 * 60,
  seconds: daysInMonthAccurate * 24 * 60 * 60,
  milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
} }, lowOrderMatrix);
function durationToMillis(matrix, vals) {
  var _a;
  let sum = (_a = vals.milliseconds) !== null && _a !== void 0 ? _a : 0;
  for (const unit of REVERSE_ORDERED_UNITS.slice(1)) {
    if (vals[unit]) {
      sum += vals[unit] * matrix[unit]["milliseconds"];
    }
  }
  return sum;
}
function eq(v1, v2) {
  if (v1 === void 0 || v1 === 0) {
    return v2 === void 0 || v2 === 0;
  }
  return v1 === v2;
}
function normalizeValues(matrix, vals) {
  const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;
  REVERSE_ORDERED_UNITS.reduce((previous, current) => {
    if (!isUndefined(vals[current])) {
      if (previous) {
        const previousVal = vals[previous] * factor;
        const conv = matrix[current][previous];
        const rollUp = Math.floor(previousVal / conv);
        vals[current] += rollUp * factor;
        vals[previous] -= rollUp * conv * factor;
      }
      return current;
    } else {
      return previous;
    }
  }, null);
  ORDERED_UNITS.reduce((previous, current) => {
    if (!isUndefined(vals[current])) {
      if (previous) {
        const fraction = vals[previous] % 1;
        vals[previous] -= fraction;
        vals[current] += fraction * matrix[previous][current];
      }
      return current;
    } else {
      return previous;
    }
  }, null);
}
function removeZeroes(vals = {}) {
  return Object.entries(vals).reduce((acc, [key, value]) => {
    if (value !== 0) {
      acc[key] = value;
    }
    return acc;
  }, {});
}
class Duration {
  static get _INVALID() {
    return "Invalid Duration";
  }
  /**
   * Returns the conversion system to use
   * @type {ConversionAccuracy}
   */
  get conversionAccuracy() {
    return this._conversionAccuracy;
  }
  /**
   * Get the days.
   * @type {number}
   */
  get days() {
    return this.isValid ? this._values.days || 0 : NaN;
  }
  /**
   * Get the hours.
   * @type {number}
   */
  get hours() {
    return this.isValid ? this._values.hours || 0 : NaN;
  }
  /**
   * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
   * @type {string}
   */
  get invalidExplanation() {
    return this._invalid ? this._invalid.explanation : null;
  }
  /**
   * Returns an error code if this Duration became invalid, or null if the Duration is valid
   * @return {string}
   */
  get invalidReason() {
    return this._invalid ? this._invalid.reason : null;
  }
  /**
   * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
   * on invalid DateTimes or Intervals.
   * @return {boolean}
   */
  get isValid() {
    return this._invalid === null;
  }
  /**
   * Get  the locale of a Duration, such 'en-GB'
   * @type {string}
   */
  get locale() {
    return this.isValid ? this._loc.locale : void 0;
  }
  /**
   * Get the conversion matrix of a Duration
   * @type {ConversionMatrix}
   */
  get matrix() {
    return this._matrix;
  }
  /**
   * Get the milliseconds.
   * @return {number}
   */
  get milliseconds() {
    return this.isValid ? this._values.milliseconds || 0 : NaN;
  }
  /**
   * Get the minutes.
   * @type {number}
   */
  get minutes() {
    return this.isValid ? this._values.minutes || 0 : NaN;
  }
  /**
   * Get the months.
   * @type {number}
   */
  get months() {
    return this.isValid ? this._values.months || 0 : NaN;
  }
  /**
   * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
   *
   * @type {NumberingSystem}
   */
  get numberingSystem() {
    return this.isValid ? this._loc.numberingSystem : void 0;
  }
  /**
   * Get the quarters.
   * @type {number}
   */
  get quarters() {
    return this.isValid ? this._values.quarters || 0 : NaN;
  }
  /**
   * Get the seconds.
   * @return {number}
   */
  get seconds() {
    return this.isValid ? this._values.seconds || 0 : NaN;
  }
  /**
   * Get the weeks
   * @type {number}
   */
  get weeks() {
    return this.isValid ? this._values.weeks || 0 : NaN;
  }
  /**
   * Get the years.
   * @type {number}
   */
  get years() {
    return this.isValid ? this._values.years || 0 : NaN;
  }
  /**
   * @private
   */
  constructor(config) {
    const accurate = config.conversionAccuracy === "longterm" || false;
    let matrix, conversionAccuracy;
    if (accurate) {
      conversionAccuracy = "longterm";
      matrix = accurateMatrix;
    } else {
      conversionAccuracy = "casual";
      matrix = casualMatrix;
    }
    if (config.matrix) {
      matrix = config.matrix;
    }
    this._values = config.values || {};
    this._loc = config.loc || Locale.create();
    this._conversionAccuracy = conversionAccuracy;
    this._invalid = config.invalid || null;
    this._matrix = matrix;
    this._isLuxonDuration = true;
  }
  /**
   * Create a Duration from DurationLike.
   *
   * @param {Object | number | Duration} durationLike
   * One of:
   * - object with keys like 'years' and 'hours'.
   * - number representing milliseconds
   * - Duration instance
   * @return {Duration}
   */
  static fromDurationLike(durationLike) {
    if (isNumber(durationLike)) {
      return Duration.fromMillis(durationLike);
    } else if (Duration.isDuration(durationLike)) {
      return durationLike;
    } else if (typeof durationLike === "object") {
      return Duration.fromObject(durationLike);
    } else {
      throw new InvalidArgumentError(`Unknown duration argument ${durationLike} of type ${typeof durationLike}`);
    }
  }
  /**
   * Create a Duration from an ISO 8601 duration string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the preset conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
   * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
   * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
   * @return {Duration}
   */
  static fromISO(text, opts) {
    const [parsed] = parseISODuration(text);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }
  /**
   * Create a Duration from an ISO 8601 time string.
   * @param {string} text - text to parse
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the conversion system to use
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
   * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
   * @return {Duration}
   */
  static fromISOTime(text, opts = {}) {
    const [parsed] = parseISOTimeOnly(text);
    if (parsed) {
      return Duration.fromObject(parsed, opts);
    } else {
      return Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
  }
  /**
   * Create Duration from a number of milliseconds.
   * @param {number} milliseconds of milliseconds
   * @param {Object} opts - options for parsing
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
   * @return {Duration}
   */
  static fromMillis(milliseconds, opts = {}) {
    return Duration.fromObject({ milliseconds }, opts);
  }
  /**
   * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
   * If this object is empty then a zero milliseconds duration is returned.
   * @param {Object} obj - the object to create the DateTime from
   * @param {number} obj.years
   * @param {number} obj.quarters
   * @param {number} obj.months
   * @param {number} obj.weeks
   * @param {number} obj.days
   * @param {number} obj.hours
   * @param {number} obj.minutes
   * @param {number} obj.seconds
   * @param {number} obj.milliseconds
   * @param {Object} [opts=[]] - options for creating this Duration
   * @param {string} [opts.locale='en-US'] - the locale to use
   * @param {string} opts.numberingSystem - the numbering system to use
   * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
   * @param {string} [opts.matrix=Object] - the custom conversion system to use
   * @return {Duration}
   */
  static fromObject(obj, opts = {}) {
    if (obj == null || typeof obj !== "object") {
      throw new InvalidArgumentError(`Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`);
    }
    return new Duration({
      values: normalizeObject(obj, Duration.normalizeUnit),
      loc: Locale.fromObject(opts),
      conversionAccuracy: opts.conversionAccuracy,
      matrix: opts.matrix
    });
  }
  /**
   * Create an invalid Duration.
   * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
   * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
   * @return {Duration}
   */
  static invalid(reason, explanation) {
    if (!reason) {
      throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
    }
    const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
    if (Settings.throwOnInvalid) {
      throw new InvalidDurationError(invalid);
    } else {
      return new Duration({ invalid });
    }
  }
  /**
   * Check if an object is a Duration. Works across context boundaries
   * @param {Object} o
   * @return {boolean}
   */
  static isDuration(o) {
    return !!o && o._isLuxonDuration || false;
  }
  /**
   * @private
   */
  static normalizeUnit(unit) {
    const normalized = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      localWeekNumber: "localWeekNumbers",
      localWeekYear: "localWeekYears",
      localWeekday: "localWeekdays",
      localWeekNumbers: "localWeekNumbers",
      localWeekYears: "localWeekYears",
      localWeekdays: "localWeekdays",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds"
    }[unit];
    if (!normalized) {
      throw new InvalidUnitError(unit);
    }
    return normalized;
  }
  // PUBLIC INSTANCE
  /**
   * Returns a string representation of this Duration appropriate for the REPL.
   * @return {string}
   */
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `Duration { values: ${JSON.stringify(this._values)} }`;
    } else {
      return `Duration { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  /**
   * Return the length of the duration in the specified unit.
   * @param {string} unit - a unit such as 'minutes' or 'days'
   * @example Duration.fromObject({years: 1}).as('days') //=> 365
   * @example Duration.fromObject({years: 1}).as('months') //=> 12
   * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
   * @return {number}
   */
  as(unit) {
    return this.shiftTo(unit).get(unit);
  }
  /**
   * Equality check
   * Two Durations are equal iff they have the same units and the same values for each unit.
   * @param {Duration} other
   * @return {boolean}
   */
  equals(other) {
    if (!this.isValid || !other.isValid) {
      return false;
    }
    if (!this._loc.equals(other._loc)) {
      return false;
    }
    for (const u of ORDERED_UNITS) {
      if (!eq(this._values[u], other._values[u])) {
        return false;
      }
    }
    return true;
  }
  /**
   * Get the value of unit.
   * @param {string} unit - a unit such as 'minute' or 'day'
   * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
   * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
   * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
   * @return {number}
   */
  get(unit) {
    return this[Duration.normalizeUnit(unit)];
  }
  getMaxUnit(onlyHuman = false) {
    const refUnits = onlyHuman ? HUMAN_ORDERED_UNITS : ORDERED_UNITS;
    const val = this.shiftTo(...refUnits).toObject();
    return refUnits.find((k) => (val[k] || 0) > 0) || REVERSE_ORDERED_UNITS[0];
  }
  /**
   * Scale this Duration by the specified amount. Return a newly-constructed Duration.
   * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
   * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
   * @return {Duration}
   */
  mapUnits(fn) {
    if (!this.isValid) {
      return this;
    }
    const result = {};
    Object.keys(this._values).forEach((unit) => {
      result[unit] = asNumber(fn(this._values[unit], unit));
    });
    return this._clone(this, { values: result }, true);
  }
  /**
   * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object} duration - The amount to subtract. Either a Luxon Duration or the object argument to Duration.fromObject()
   * @return {Duration}
   */
  minus(duration) {
    if (!this.isValid) {
      return this;
    }
    const dur = Duration.fromDurationLike(duration);
    return this.plus(dur.negate());
  }
  /**
   * Return the negative of this Duration.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
   * @return {Duration}
   */
  negate() {
    if (!this.isValid) {
      return this;
    }
    const negated = {};
    Object.keys(this._values).forEach((unit) => {
      negated[unit] = this._values[unit] === 0 ? 0 : -this._values[unit];
    });
    return this._clone(this, { values: negated }, true);
  }
  /**
   * Reduce this Duration to its canonical representation in its current units.
   * Assuming the overall value of the Duration is positive, this means:
   * - excessive values for lower-order units are converted to higher order units (if possible, see first and second example)
   * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
   *   the overall value would be negative, see third example)
   *
   * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
   * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
   * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
   * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
   * @return {Duration}
   */
  normalize() {
    if (!this.isValid) {
      return this;
    }
    const vals = this.toObject();
    normalizeValues(this._matrix, vals);
    return this._clone(this, { values: vals }, true);
  }
  /**
   * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
   * @param {Duration|Object} duration - The amount to add. Either a Luxon Duration or the object argument to Duration.fromObject()
   * @return {Duration}
   */
  plus(duration) {
    if (!this.isValid) {
      return this;
    }
    const dur = Duration.fromDurationLike(duration), result = {};
    ORDERED_UNITS.forEach((unit) => {
      if (dur._values[unit] !== void 0 || this._values[unit] !== void 0) {
        result[unit] = dur.get(unit) + this.get(unit);
      }
    });
    return this._clone(this, { values: result }, true);
  }
  /**
   * "Set" the locale and/or numberingSystem and/or conversionAccuracy. Returns a newly-constructed Duration.
   * @example dur.reconfigure({ locale: 'en-GB' })
   * @return {Duration}
   */
  reconfigure({ locale, numberingSystem, conversionAccuracy, matrix } = {}) {
    const loc = this._loc.clone({ locale, numberingSystem });
    const opts = { loc, matrix, conversionAccuracy };
    return this._clone(this, opts);
  }
  /**
   * Removes all units with values equal to 0 from this Duration.
   * @example Duration.fromObject({ years: 2, days: 0, hours: 0, minutes: 0 }).removeZeros().toObject() //=> { years: 2 }
   * @return {Duration}
   */
  removeZeroes() {
    if (!this.isValid) {
      return this;
    }
    const vals = removeZeroes(this._values);
    return this._clone(this, { values: vals }, true);
  }
  /**
   * Rescale units to its largest representation
   * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
   * @return {Duration}
   */
  rescale() {
    if (!this.isValid) {
      return this;
    }
    const vals = removeZeroes(this.normalize().shiftToAll().toObject());
    return this._clone(this, { values: vals }, true);
  }
  /**
   * "Set" the values of specified units. Non-specified units stay unchanged. Return a newly-constructed Duration.
   * @param {Object} values - a mapping of units to numbers
   * @example dur.set({ years: 2017 })
   * @example dur.set({ hours: 8, minutes: 30 })
   * @return {Duration}
   */
  set(values) {
    if (!this.isValid) {
      return this;
    }
    const mixed = Object.assign(Object.assign({}, this._values), normalizeObject(values, Duration.normalizeUnit));
    return this._clone(this, { values: mixed });
  }
  /**
   * Convert this Duration into its representation in a different set of units.
   * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
   * @return {Duration}
   */
  shiftTo(...units) {
    if (!this.isValid || units.length === 0) {
      return this;
    }
    units = units.map((u) => Duration.normalizeUnit(u));
    const built = {}, accumulated = {}, vals = this.toObject();
    let lastUnit;
    ORDERED_UNITS.forEach((k) => {
      if (units.indexOf(k) >= 0) {
        lastUnit = k;
        let own = 0;
        Object.keys(accumulated).forEach((ak) => {
          own += this._matrix[ak][k] * accumulated[ak];
          accumulated[ak] = 0;
        });
        if (isNumber(vals[k])) {
          own += vals[k];
        }
        const i = Math.trunc(own);
        built[k] = i;
        accumulated[k] = (own * 1e3 - i * 1e3) / 1e3;
      } else if (isNumber(vals[k])) {
        accumulated[k] = vals[k];
      }
    });
    Object.keys(accumulated).forEach((key) => {
      const v = accumulated[key];
      if (v !== 0) {
        built[lastUnit] += key === lastUnit ? v : v / this._matrix[lastUnit][key];
      }
    });
    return this._clone(this, { values: built }, true).normalize();
  }
  /**
   * Shift this Duration to all available units.
   * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
   * @return {Duration}
   */
  shiftToAll() {
    if (!this.isValid) {
      return this;
    }
    return this.shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds");
  }
  /**
   * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
   * * `S` for milliseconds
   * * `s` for seconds
   * * `m` for minutes
   * * `h` for hours
   * * `d` for days
   * * `w` for weeks
   * * `M` for months
   * * `y` for years
   * Notes:
   * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
   * * Tokens can be escaped by wrapping with single quotes.
   * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations' conversion accuracy setting.
   * @param {string} fmt - the format string
   * @param {Object} opts - options
   * @param {boolean} [opts.floor=true] - floor numerical values
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
   * @return {string}
   */
  toFormat(fmt, opts = { floor: true }) {
    const fmtOpts = Object.assign(Object.assign({}, opts), { floor: opts.round !== false && opts.floor !== false });
    return this.isValid ? Formatter.create(this._loc, fmtOpts).formatDurationFromString(this, fmt) : Duration._INVALID;
  }
  /**
   * Returns a string representation of a Duration with all units included.
   * To modify its behavior, use `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options
   * @param {Object} opts - Formatting options. Accepts the same keys as the options parameter of the native `Intl.NumberFormat` constructor, as well as `listStyle`.
   * @param {string} [opts.listStyle='narrow'] - How to format the merged list. Corresponds to the `style` property of the options parameter of the native `Intl.ListFormat` constructor.
   * @param {boolean} [opts.showZeros=true] - Show all units previously used by the duration even if they are zero
   * @example
   * ```js
   * var dur = Duration.fromObject({ months: 1, weeks: 0, hours: 5, minutes: 6 })
   * dur.toHuman() //=> '1 month, 0 weeks, 5 hours, 6 minutes'
   * dur.toHuman({ listStyle: "long" }) //=> '1 month, 0 weeks, 5 hours, and 6 minutes'
   * dur.toHuman({ unitDisplay: "short" }) //=> '1 mth, 0 wks, 5 hr, 6 min'
   * dur.toHuman({ showZeros: false }) //=> '1 month, 5 hours, 6 minutes'
   * ```
   */
  toHuman(opts = {}) {
    if (!this.isValid) {
      return Duration._INVALID;
    }
    const showZeroes = opts.showZeros === true;
    const maxUnit = this.getMaxUnit(true);
    const refUnits = !!opts.onlyHumanUnits ? HUMAN_ORDERED_UNITS : ORDERED_UNITS;
    const shifted = this.shiftTo(...refUnits.slice(refUnits.indexOf(maxUnit)));
    const shiftedValues = shifted.toObject();
    const l = refUnits.map((unit) => {
      const val = shiftedValues[unit];
      if (isUndefined(val) || val === 0 && !showZeroes) {
        return null;
      }
      return this._loc.numberFormatter(Object.assign(Object.assign({ style: "unit", unitDisplay: "long" }, opts), { unit: unit.slice(0, -1) })).format(val);
    }).filter((n) => n);
    const mergedOpts = Object.assign({ type: "conjunction", style: opts.listStyle || "narrow" }, opts);
    return this._loc.listFormatter(mergedOpts).format(l);
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
   * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
   * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
   * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
   * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
   * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
   * @return {string}
   */
  toISO() {
    if (!this.isValid) {
      return null;
    }
    let s = "P";
    if (this.years !== 0) {
      s += this.years + "Y";
    }
    if (this.months !== 0 || this.quarters !== 0) {
      s += this.months + this.quarters * 3 + "M";
    }
    if (this.weeks !== 0) {
      s += this.weeks + "W";
    }
    if (this.days !== 0) {
      s += this.days + "D";
    }
    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) {
      s += "T";
    }
    if (this.hours !== 0) {
      s += this.hours + "H";
    }
    if (this.minutes !== 0) {
      s += this.minutes + "M";
    }
    if (this.seconds !== 0 || this.milliseconds !== 0) {
      s += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
    }
    if (s === "P") {
      s += "T0S";
    }
    return s;
  }
  /**
   * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
   * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
   * @see https://en.wikipedia.org/wiki/ISO_8601#Times
   * @param {Object} opts - options
   * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
   * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
   * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
   * @param {string} [opts.format='extended'] - choose between the basic and extended format
   * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
   * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
   * @return {string}
   */
  toISOTime(opts = {}) {
    if (!this.isValid) {
      return null;
    }
    const millis = this.toMillis();
    if (millis < 0 || millis >= 864e5) {
      return null;
    }
    opts = Object.assign(Object.assign({ suppressMilliseconds: false, suppressSeconds: false, includePrefix: false, format: "extended" }, opts), { includeOffset: false });
    const dateTime = DateTime.fromMillis(millis, { zone: "UTC" });
    return dateTime.toISOTime(opts);
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
   * @return {string}
   */
  toJSON() {
    return this.toISO();
  }
  /**
   * Returns the value of this Duration in milliseconds.
   * @return {number}
   */
  toMillis() {
    if (!this.isValid) {
      return NaN;
    }
    return durationToMillis(this.matrix, this._values);
  }
  /**
   * Returns a JavaScript object with this Duration's values.
   * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
   * @return {Object}
   */
  toObject() {
    if (!this.isValid) {
      return {};
    }
    return Object.assign({}, this._values);
  }
  /**
   * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
   * @return {string}
   */
  toString() {
    return this.toISO();
  }
  /**
   * Returns a milliseconds value of this Duration. Alias of {@link toMillis}
   * @return {number}
   */
  valueOf() {
    return this.toMillis();
  }
  /**
   * @private
   */
  // clone really means "create another instance just like this one, but with these changes"
  _clone(dur, alts, clear = false) {
    const conf = {
      values: clear ? alts.values : Object.assign(Object.assign({}, dur._values), alts.values || {}),
      loc: dur._loc.clone(alts.loc),
      conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
      matrix: alts.matrix || dur.matrix
    };
    return new Duration(conf);
  }
}
var duration_default = Duration;
export {
  Duration,
  casualMatrix,
  duration_default as default,
  lowOrderMatrix
};
