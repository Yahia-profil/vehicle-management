var __rest = function(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
import { padStart, roundTo, hasRelative, hasLocaleWeekInfo, FALLBACK_WEEK_SETTINGS, validateWeekSettings } from "./util.js";
import * as English from "./english.js";
import { Settings } from "../settings.js";
import { DateTime } from "../datetime.js";
import { IANAZone } from "../zones/IANAZone.js";
import { LocaleCache } from "./locale-cache.js";
function parseLocaleString(localeStr) {
  const xIndex = localeStr.indexOf("-x-");
  if (xIndex !== -1) {
    localeStr = localeStr.substring(0, xIndex);
  }
  const uIndex = localeStr.indexOf("-u-");
  if (uIndex === -1) {
    return [localeStr];
  } else {
    let options;
    let selectedStr;
    try {
      options = LocaleCache.getCachedDTF(localeStr).resolvedOptions();
      selectedStr = localeStr;
    } catch (e) {
      const smaller = localeStr.substring(0, uIndex);
      options = LocaleCache.getCachedDTF(smaller).resolvedOptions();
      selectedStr = smaller;
    }
    const { numberingSystem, calendar } = options;
    return [selectedStr, numberingSystem, calendar];
  }
}
function intlConfigString(localeStr, numberingSystem, outputCalendar) {
  if (outputCalendar || numberingSystem) {
    if (!localeStr.includes("-u-")) {
      localeStr += "-u";
    }
    if (outputCalendar) {
      localeStr += `-ca-${outputCalendar}`;
    }
    if (numberingSystem) {
      localeStr += `-nu-${numberingSystem}`;
    }
    return localeStr;
  } else {
    return localeStr;
  }
}
function mapMonths(f) {
  const ms = [];
  for (let i = 1; i <= 12; i++) {
    const dt = DateTime.utc(2009, i, 1);
    ms.push(f(dt));
  }
  return ms;
}
function mapWeekdays(f) {
  const ms = [];
  for (let i = 1; i <= 7; i++) {
    const dt = DateTime.utc(2016, 11, 13 + i);
    ms.push(f(dt));
  }
  return ms;
}
function listStuff(loc, length, englishFn, intlFn) {
  const mode = loc.listingMode();
  if (mode === "en") {
    return englishFn(length);
  } else {
    return intlFn(length);
  }
}
class PolyNumberFormatter {
  constructor(intl, forceSimple, opts) {
    const { padTo, floor } = opts, otherOpts = __rest(opts, ["padTo", "floor"]);
    this._padTo = padTo || 0;
    this._floor = floor || false;
    if (!forceSimple || Object.keys(otherOpts).length > 0) {
      const intlOpts = Object.assign({ useGrouping: false }, opts);
      if (this._padTo > 0) {
        intlOpts.minimumIntegerDigits = padTo;
      }
      this._inf = LocaleCache.getCachedINF(intl, intlOpts);
    }
  }
  format(i) {
    if (this._inf) {
      const fixed = this._floor ? Math.floor(i) : i;
      return this._inf.format(fixed);
    } else {
      const fixed = this._floor ? Math.floor(i) : roundTo(i, 3);
      return padStart(fixed, this._padTo);
    }
  }
}
class PolyDateFormatter {
  get dtf() {
    return this._dtf;
  }
  constructor(dt, intl, opts) {
    this._opts = opts;
    let z;
    if (this._opts.timeZone) {
      this._dt = dt;
    } else if (dt.zone.type === "fixed") {
      const gmtOffset = -1 * (dt.offset / 60);
      const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
      if (dt.offset !== 0 && IANAZone.create(offsetZ).isValid) {
        z = offsetZ;
        this._dt = dt;
      } else {
        z = "UTC";
        this._dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({ minutes: dt.offset });
        this._originalZone = dt.zone;
      }
    } else if (dt.zone.type === "system") {
      this._dt = dt;
    } else if (dt.zone.type === "iana") {
      this._dt = dt;
      z = dt.zone.name;
    } else {
      z = "UTC";
      this._dt = dt.setZone("UTC").plus({ minutes: dt.offset });
      this._originalZone = dt.zone;
    }
    const intlOpts = Object.assign(Object.assign({}, this._opts), { timeZone: this._opts.timeZone || z });
    this._dtf = LocaleCache.getCachedDTF(intl, intlOpts);
  }
  format() {
    if (this._originalZone) {
      return this.formatToParts().map(({ value }) => value).join("");
    }
    return this.dtf.format(this._dt.toJSDate());
  }
  formatToParts() {
    const parts = this.dtf.formatToParts(this._dt.toJSDate());
    if (!!this._originalZone) {
      return parts.map((part) => {
        if (part.type === "timeZoneName") {
          const offsetName = this._originalZone.offsetName(this._dt.ts, {
            locale: this._dt.locale,
            format: this._opts.timeZoneName
          });
          return Object.assign(Object.assign({}, part), {
            // tslint:disable-next-line:no-non-null-assertion
            value: offsetName
          });
        } else {
          return part;
        }
      });
    }
    return parts;
  }
  resolvedOptions() {
    return this._dtf.resolvedOptions();
  }
}
class PolyRelFormatter {
  constructor(locale, isEnglish, opts) {
    this._opts = Object.assign({ style: "long" }, opts);
    if (!isEnglish && hasRelative()) {
      this._rtf = LocaleCache.getCachedRTF(locale, opts);
    }
  }
  format(count, unit) {
    if (this._rtf) {
      return this._rtf.format(count, unit);
    } else {
      return English.formatRelativeTime(unit, count, this._opts.numeric, this._opts.style !== "long");
    }
  }
  formatToParts(count, unit) {
    if (this._rtf) {
      return this._rtf.formatToParts(count, unit);
    } else {
      return [];
    }
  }
}
class Locale {
  get fastNumbers() {
    if (this._fastNumbersCached === void 0) {
      this._fastNumbersCached = this._supportsFastNumbers();
    }
    return this._fastNumbersCached;
  }
  constructor(locale, numberingSystem, outputCalendar, weekSettings, specifiedLocale) {
    const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
    this.locale = parsedLocale;
    this.numberingSystem = numberingSystem || parsedNumberingSystem;
    this.outputCalendar = outputCalendar || parsedOutputCalendar;
    this._intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
    this._weekSettings = weekSettings;
    this._weekdaysCache = { format: {}, standalone: {} };
    this._monthsCache = { format: {}, standalone: {} };
    this._meridiemCache = void 0;
    this._eraCache = {};
    this._specifiedLocale = specifiedLocale;
    this._fastNumbersCached = void 0;
  }
  static create(locale, numberingSystem, outputCalendar, weekSettings, defaultToEN = false) {
    const specifiedLocale = locale || Settings.defaultLocale;
    const localeR = specifiedLocale || (defaultToEN ? "en-US" : LocaleCache.systemLocale());
    const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
    const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
    const weekSettingsR = validateWeekSettings(weekSettings) || Settings.defaultWeekSettings;
    return new Locale(localeR, numberingSystemR, outputCalendarR, weekSettingsR, specifiedLocale);
  }
  static fromObject({ locale, numberingSystem, outputCalendar, weekSettings } = {}) {
    return Locale.create(locale, numberingSystem, outputCalendar, weekSettings);
  }
  static fromOpts(opts) {
    return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.weekSettings, opts.defaultToEN);
  }
  static resetCache() {
    LocaleCache.reset();
  }
  //
  clone(alts) {
    if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
      return this;
    } else {
      return Locale.create(alts.locale || this._specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, validateWeekSettings(alts.weekSettings) || this._weekSettings, alts.defaultToEN || false);
    }
  }
  dtFormatter(dt, intlOptions = {}) {
    return new PolyDateFormatter(dt, this._intl, intlOptions);
  }
  equals(other) {
    return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
  }
  eras(length) {
    return listStuff(this, length, English.eras, (len) => {
      const intl = { era: len };
      if (!this._eraCache[len]) {
        this._eraCache[len] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map((dt) => this.extract(dt, intl, "era"));
      }
      return this._eraCache[len];
    });
  }
  extract(dt, intlOptions, field) {
    const df = this.dtFormatter(dt, intlOptions), results = df.formatToParts(), matching = results.find((m) => m.type.toLowerCase() === field.toLowerCase());
    if (!matching) {
      throw new Error(`Invalid extract field ${field}`);
    }
    return matching.value;
  }
  getMinDaysInFirstWeek() {
    return this.getWeekSettings().minimalDays;
  }
  getStartOfWeek() {
    return this.getWeekSettings().firstDay;
  }
  getWeekSettings() {
    if (this._weekSettings) {
      return this._weekSettings;
    } else if (!hasLocaleWeekInfo()) {
      return FALLBACK_WEEK_SETTINGS;
    } else {
      return this._getCachedWeekInfo(this.locale);
    }
  }
  getWeekendDays() {
    return this.getWeekSettings().weekend;
  }
  isEnglish() {
    return (
      // tslint:disable-next-line:no-bitwise
      !!~["en", "en-us"].indexOf(this.locale.toLowerCase()) || LocaleCache.getCachedIntResolvedOptions(this._intl).locale.startsWith("en-us")
    );
  }
  listFormatter(opts = {}) {
    return LocaleCache.getCachedLF(this._intl, opts);
  }
  // In Luxon boolean param "defaultOK" was still there, although unused
  listingMode() {
    const isActuallyEn = this.isEnglish();
    const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return isActuallyEn && hasNoWeirdness ? "en" : "intl";
  }
  meridiems() {
    return listStuff(
      this,
      "long",
      // arbitrary unused value
      () => English.meridiems,
      () => {
        if (this._meridiemCache === void 0) {
          this._meridiemCache = [
            DateTime.utc(2016, 11, 13, 9),
            DateTime.utc(2016, 11, 13, 19)
          ].map((dt) => this.extract(dt, { hour: "numeric", hourCycle: "h12" }, "dayPeriod"));
        }
        return this._meridiemCache;
      }
    );
  }
  months(length, format = false) {
    return listStuff(this, length, English.months, (len) => {
      const intl = format ? { month: len, day: "numeric" } : { month: len };
      const formatStr = format ? "format" : "standalone";
      if (!this._monthsCache[formatStr][len]) {
        this._monthsCache[formatStr][len] = mapMonths((dt) => this.extract(dt, intl, "month"));
      }
      return this._monthsCache[formatStr][len];
    });
  }
  numberFormatter(options = {}) {
    return new PolyNumberFormatter(this._intl, this.fastNumbers, options);
  }
  redefaultToEN(alts = {}) {
    return this.clone(Object.assign(Object.assign({}, alts), { defaultToEN: true }));
  }
  redefaultToSystem(alts = {}) {
    return this.clone(Object.assign(Object.assign({}, alts), { defaultToEN: false }));
  }
  relFormatter(options = {}) {
    return new PolyRelFormatter(this._intl, this.isEnglish(), options);
  }
  toString() {
    return `Locale(${this.locale}, ${this.numberingSystem}, ${this.outputCalendar})`;
  }
  weekdays(length, format = false) {
    return listStuff(this, length, English.weekdays, (len) => {
      const intl = format ? { weekday: len, year: "numeric", month: "long", day: "numeric" } : { weekday: len };
      const formatStr = format ? "format" : "standalone";
      if (!this._weekdaysCache[formatStr][len]) {
        this._weekdaysCache[formatStr][len] = mapWeekdays((dt) => this.extract(dt, intl, "weekday"));
      }
      return this._weekdaysCache[formatStr][len];
    });
  }
  //
  _getCachedWeekInfo(locString) {
    if (!Locale._weekInfoCache.has(locString)) {
      const locale = new Intl.Locale(locString);
      let data = "getWeekInfo" in locale ? locale.getWeekInfo() : locale.weekInfo;
      if (!("minimalDays" in data)) {
        data = Object.assign(Object.assign({}, FALLBACK_WEEK_SETTINGS), data);
      }
      Locale._weekInfoCache.set(locString, data);
    }
    return Locale._weekInfoCache.get(locString);
  }
  _supportsFastNumbers() {
    if (this.numberingSystem && this.numberingSystem !== "latn") {
      return false;
    } else {
      return this.numberingSystem === "latn" || !this.locale || this.locale.startsWith("en") || Intl.DateTimeFormat(this._intl).resolvedOptions().numberingSystem === "latn";
    }
  }
}
Locale._weekInfoCache = /* @__PURE__ */ new Map();
export {
  Locale,
  PolyDateFormatter
};
