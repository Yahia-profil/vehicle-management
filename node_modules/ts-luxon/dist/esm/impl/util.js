import { InvalidArgumentError } from "../errors.js";
import { Settings } from "../settings.js";
import { dayOfWeek, isoWeekdayToLocal } from "./conversions.js";
function isDefined(o) {
  return typeof o !== "undefined";
}
function isUndefined(o) {
  return typeof o === "undefined";
}
function isNumber(o) {
  return typeof o === "number";
}
function isInteger(o) {
  return isNumber(o) && o % 1 === 0;
}
function isString(o) {
  return typeof o === "string";
}
function isDate(o) {
  return Object.prototype.toString.call(o) === "[object Date]";
}
function hasRelative() {
  try {
    return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
  } catch (e) {
    return false;
  }
}
function hasLocaleWeekInfo() {
  try {
    return typeof Intl !== "undefined" && !!Intl.Locale && ("weekInfo" in Intl.Locale.prototype || "getWeekInfo" in Intl.Locale.prototype);
  } catch (e) {
    return false;
  }
}
function maybeArray(thing) {
  return Array.isArray(thing) ? thing : [thing];
}
function bestBy(arr, by, compare) {
  if (arr.length === 0) {
    return void 0;
  }
  const bestResult = arr.reduce((best, next) => {
    const pair = [by(next), next];
    if (compare(best[0], pair[0]) === best[0]) {
      return best;
    }
    return pair;
  }, [by(arr[0]), arr[0]]);
  return bestResult[1];
}
function pick(obj, keys) {
  return keys.reduce((a, k) => {
    a[k] = obj[k];
    return a;
  }, {});
}
function validateWeekSettings(settings) {
  if (!settings) {
    return void 0;
  } else if (typeof settings !== "object") {
    throw new InvalidArgumentError("Week settings must be an object");
  } else {
    if (!integerBetween(settings.firstDay, 1, 7) || !integerBetween(settings.minimalDays, 1, 7) || !Array.isArray(settings.weekend) || settings.weekend.some((v) => !integerBetween(v, 1, 7))) {
      throw new InvalidArgumentError("Invalid week settings");
    }
    return {
      firstDay: settings.firstDay,
      minimalDays: settings.minimalDays,
      weekend: settings.weekend
    };
  }
}
function integerBetween(thing, bottom, top) {
  return isInteger(thing) && thing >= bottom && thing <= top;
}
function floorMod(x, n) {
  return x - n * Math.floor(x / n);
}
function padStart(input, n = 2) {
  const minus = +input < 0 ? "-" : "";
  const target = minus ? +input * -1 : input;
  let result;
  if (target.toString().length < n) {
    result = ("0".repeat(n) + target).slice(-n);
  } else {
    result = target.toString();
  }
  return `${minus}${result}`;
}
function parseInteger(text) {
  if (!!text) {
    return parseInt(text, 10);
  }
  return void 0;
}
function parseFloating(text) {
  if (!!text) {
    return parseFloat(text);
  }
  return void 0;
}
function parseMillis(fraction) {
  if (isUndefined(fraction) || fraction === null || fraction === "") {
    return void 0;
  } else {
    const f = parseFloat("0." + fraction) * 1e3;
    return Math.floor(f);
  }
}
function roundTo(value, digits, rounding = "round") {
  const factor = Math.pow(10, digits);
  switch (rounding) {
    case "expand":
      return value > 0 ? Math.ceil(value * factor) / factor : Math.floor(value * factor) / factor;
    case "trunc":
      return Math.trunc(value * factor) / factor;
    case "round":
      return Math.round(value * factor) / factor;
    case "floor":
      return Math.floor(value * factor) / factor;
    case "ceil":
      return Math.ceil(value * factor) / factor;
    default:
      throw new RangeError(`Value rounding ${rounding} is out of range`);
  }
}
function isLeapYear(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
function daysInMonth(year, month) {
  const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
  return [31, isLeapYear(modYear) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
}
function objToLocalTS(obj) {
  let d = Date.UTC(obj.year, obj.month - 1, obj.day, obj.hour, obj.minute, obj.second, obj.millisecond);
  if (obj.year < 100 && obj.year >= 0) {
    d = new Date(d);
    d.setUTCFullYear(obj.year, obj.month - 1, obj.day);
  }
  return +d;
}
function firstWeekOffset(year, minDaysInFirstWeek, startOfWeek) {
  const fwdlw = isoWeekdayToLocal(dayOfWeek(year, 1, minDaysInFirstWeek), startOfWeek);
  return -fwdlw + minDaysInFirstWeek - 1;
}
function weeksInWeekYear(weekYear, minDaysInFirstWeek = 4, startOfWeek = 1) {
  const weekOffset = firstWeekOffset(weekYear, minDaysInFirstWeek, startOfWeek);
  const weekOffsetNext = firstWeekOffset(weekYear + 1, minDaysInFirstWeek, startOfWeek);
  return (daysInYear(weekYear) - weekOffset + weekOffsetNext) / 7;
}
function untruncateYear(year) {
  if (year > 99) {
    return year;
  } else {
    return year > Settings.twoDigitCutoffYear ? 1900 + year : 2e3 + year;
  }
}
function parseZoneInfo(ts, offsetFormat, locale, timeZone) {
  const date = new Date(ts);
  const intlOpts = {
    hourCycle: "h23",
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    timeZone
  };
  const modified = Object.assign({ timeZoneName: offsetFormat }, intlOpts);
  const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date).find((m) => m.type.toLowerCase() === "timezonename");
  return parsed ? parsed.value : null;
}
function signedOffset(offHourStr, offMinuteStr) {
  let offHour = parseInt(offHourStr, 10);
  if (Number.isNaN(offHour)) {
    offHour = 0;
  }
  const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
  return offHour * 60 + offMinSigned;
}
function asNumber(value) {
  const numericValue = Number(value);
  if (typeof value === "boolean" || value === "" || Number.isNaN(numericValue)) {
    throw new InvalidArgumentError(`Invalid unit value ${value}`);
  }
  return numericValue;
}
function normalizeObject(obj, normalizer) {
  return Object.keys(obj).reduce((acc, u) => {
    obj[u] !== void 0 && obj[u] !== null && (acc[normalizer(u)] = asNumber(obj[u]));
    return acc;
  }, {});
}
function formatOffset(offset, format) {
  const hours = Math.trunc(Math.abs(offset / 60)), minutes = Math.trunc(Math.abs(offset % 60)), sign = offset >= 0 ? "+" : "-";
  switch (format) {
    case "short":
      return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
    case "narrow":
      return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
    case "techie":
      return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;
    default:
      throw new RangeError(`Value format ${format} is out of range for property format`);
  }
}
function timeObject(obj) {
  return pick(obj, ["hour", "minute", "second", "millisecond"]);
}
const ORDERED_UNITS = [
  "years",
  "quarters",
  "months",
  "weeks",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
];
const REVERSE_ORDERED_UNITS = ORDERED_UNITS.slice(0).reverse();
const HUMAN_ORDERED_UNITS = [
  "years",
  "months",
  "days",
  "hours",
  "minutes",
  "seconds",
  "milliseconds"
];
const PLURAL_MAPPING = {
  year: "year",
  years: "year",
  quarter: "quarter",
  quarters: "quarter",
  month: "month",
  months: "month",
  day: "day",
  days: "day",
  hour: "hour",
  hours: "hour",
  localweeknumber: "localWeekNumber",
  localweeknumbers: "localWeekNumber",
  localweekday: "localWeekday",
  localweekdays: "localWeekday",
  localweekyear: "localWeekYear",
  localweekyears: "localWeekYear",
  minute: "minute",
  minutes: "minute",
  second: "second",
  seconds: "second",
  millisecond: "millisecond",
  milliseconds: "millisecond",
  weekday: "weekday",
  weekdays: "weekday",
  weeknumber: "weekNumber",
  weeksnumber: "weekNumber",
  weeknumbers: "weekNumber",
  weekyear: "weekYear",
  weekyears: "weekYear",
  ordinal: "ordinal"
};
const FALLBACK_WEEK_SETTINGS = {
  firstDay: 1,
  minimalDays: 4,
  weekend: [6, 7]
};
export {
  FALLBACK_WEEK_SETTINGS,
  HUMAN_ORDERED_UNITS,
  ORDERED_UNITS,
  PLURAL_MAPPING,
  REVERSE_ORDERED_UNITS,
  asNumber,
  bestBy,
  daysInMonth,
  daysInYear,
  floorMod,
  formatOffset,
  hasLocaleWeekInfo,
  hasRelative,
  integerBetween,
  isDate,
  isDefined,
  isInteger,
  isLeapYear,
  isNumber,
  isString,
  isUndefined,
  maybeArray,
  normalizeObject,
  objToLocalTS,
  padStart,
  parseFloating,
  parseInteger,
  parseMillis,
  parseZoneInfo,
  pick,
  roundTo,
  signedOffset,
  timeObject,
  untruncateYear,
  validateWeekSettings,
  weeksInWeekYear
};
