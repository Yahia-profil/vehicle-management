import { formatOffset, parseZoneInfo, isUndefined, objToLocalTS } from "../impl/util.js";
import { Zone } from "../zone.js";
import { InvalidZoneError } from "../errors.js";
const dtfCache = /* @__PURE__ */ new Map();
function makeDTF(zoneName) {
  if (!dtfCache.has(zoneName)) {
    try {
      dtfCache.set(zoneName, new Intl.DateTimeFormat("en-US", {
        hour12: false,
        timeZone: zoneName,
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        era: "short"
      }));
    } catch (_a) {
      throw new InvalidZoneError(zoneName);
    }
  }
  return dtfCache.get(zoneName);
}
const typeToPos = {
  year: 0,
  month: 1,
  day: 2,
  era: 3,
  hour: 4,
  minute: 5,
  second: 6
};
function hackyOffset(dtf, date) {
  const formatted = dtf.format(date).replace(/\u200E/g, "");
  const parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted);
  const [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
  return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
}
function partsOffset(dtf, date) {
  const formatted = dtf.formatToParts(date);
  const filled = [];
  for (let i = 0; i < formatted.length; i++) {
    const { type, value } = formatted[i];
    const pos = typeToPos[type];
    if (type === "era") {
      filled[pos] = value;
    } else if (!isUndefined(pos)) {
      filled[pos] = parseInt(value, 10);
    }
  }
  return filled;
}
const ianaZoneCache = /* @__PURE__ */ new Map();
class IANAZone extends Zone {
  /** @override **/
  get isUniversal() {
    return false;
  }
  /** @override **/
  get isValid() {
    return this._valid;
  }
  /** @override **/
  get name() {
    return this._zoneName;
  }
  /** @override **/
  get type() {
    return "iana";
  }
  constructor(name) {
    super();
    this._zoneName = name;
    this._valid = IANAZone.isValidZone(name);
  }
  /**
   * @param {string} name - Zone name
   * @return {IANAZone}
   */
  static create(name) {
    if (!ianaZoneCache.has(name)) {
      ianaZoneCache.set(name, new IANAZone(name));
    }
    return ianaZoneCache.get(name);
  }
  /**
   * Returns whether the provided string is a valid specifier.
   * This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
   * @param {string} s - The string to check validity on
   * @example IANAZone.isValidSpecifier("America/New_York") //=> true
   * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
   * @deprecated This method returns false for some valid IANA names. Use isValidZone instead.
   * @return {boolean}
   */
  static isValidSpecifier(s) {
    return this.isValidZone(s);
  }
  /**
   * Returns whether the provided string identifies a real zone
   * @param {string} zone - The string to check
   * @example IANAZone.isValidZone("America/New_York") //=> true
   * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
   * @example IANAZone.isValidZone("Sport~~blorp") //=> false
   * @return {boolean}
   */
  static isValidZone(zone) {
    if (!zone) {
      return false;
    }
    try {
      new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Reset local caches. Should only be necessary in testing scenarios.
   * @return {void}
   */
  static resetCache() {
    ianaZoneCache.clear();
    dtfCache.clear();
  }
  /** @override **/
  equals(other) {
    return other.type === "iana" && other.name === this.name;
  }
  /** @override **/
  formatOffset(ts, format) {
    return formatOffset(this.offset(ts), format);
  }
  /**
   * Return the offset in minutes for this zone at the specified timestamp.
   * @override
   * @param {number} ts - Epoch milliseconds for which to compute the offset
   * @return {number}
   */
  offset(ts) {
    const date = new Date(ts);
    if (!this._valid || isNaN(+date)) {
      return NaN;
    }
    const dtf = makeDTF(this.name);
    let yearAlt;
    const [year, month, day, adOrBc, hour, minute, second] = typeof dtf.formatToParts === typeof isNaN ? partsOffset(dtf, date) : hackyOffset(dtf, date);
    if (adOrBc === "BC") {
      yearAlt = -Math.abs(+year) + 1;
    }
    const adjustedHour = hour === 24 ? 0 : hour;
    const asUTC = objToLocalTS({
      year: yearAlt || +year,
      month: +month,
      day: +day,
      hour: +adjustedHour,
      minute: +minute,
      second: +second,
      millisecond: 0
    });
    let asTS = +date;
    const over = asTS % 1e3;
    asTS -= over >= 0 ? over : 1e3 + over;
    return (asUTC - asTS) / (60 * 1e3);
  }
  /** @override **/
  offsetName(ts, { format, locale } = {}) {
    return parseZoneInfo(ts, format, locale, this.name);
  }
}
export {
  IANAZone
};
